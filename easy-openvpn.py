#!/usr/bin/env python3
import os
import sys

from OpenSSL import crypto

from cryptography.hazmat.primitives.serialization import Encoding
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.backends.interfaces import DHBackend
from cryptography.hazmat.backends.openssl.backend import backend
from cryptography.hazmat.primitives.serialization import ParameterFormat


CERT_TYPE_CA = 'ca'
CERT_TYPE_CLIENT = 'client'
CERT_TYPE_SERVER = 'server'

CONFIG_TEMPLATE = """# generated by easy-openvpn
{host}
proto udp
dev tun
cipher AES-256-CBC
compress lzo
persist-key
persist-tun
verb 3
{ca}
{cert}
{key}
{dh}
"""


def _generate_diffie_hellman(name, key_size):
    """
    https://stackoverflow.com/questions/39534456/how-to-generate-diffie-hellman-parameters-in-python
    """
    DHBackend.generate_dh_parameters(backend, generator=2, key_size=key_size)
    dh_parameters = dh.generate_parameters(generator=2, key_size=key_size, backend=backend)
    with open('{}.pem'.format(name), 'wb') as output:
        output.write(dh_parameters.parameter_bytes(Encoding.PEM, ParameterFormat.PKCS3))


def _generate(cert_type, name, ca_name=None, dh_name=None, host_name=None, is_embed=True):
    """
    (internal use only)
    generates a new x509 certificate (CA or end-entity)
    https://github.com/openwisp/django-x509/blob/master/django_x509/base/models.py#L288
    """
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 4096)

    cert = crypto.X509()
    subject = cert.get_subject()
    data = {
        'C': 'AQ',
        'ST': 'Concordia Station',
        'L': 'Dome C',
        'O': 'VOID',
        'OU': 'HQ',
        'CN': name,
    }
    for k, v in data.items():
        if hasattr(subject, k):
            setattr(subject, k, v)

    cert.set_version(0x2)  # version 3 (0 indexed counting)
    cert.set_subject(subject)
    cert.set_serial_number(0)
    cert.set_notBefore(b'20080512000000Z')
    cert.set_notAfter(b'21080512000000Z')

    ca_cert = None

    if cert_type == CERT_TYPE_CA:  # generating certificate for CA
        issuer = cert.get_subject()
        issuer_key = key

    else:  # generating certificate issued by a CA
        with open('{}_cert.pem'.format(ca_name), 'rb') as f:
            ca_cert = crypto.load_certificate(crypto.FILETYPE_PEM, f.read())
            issuer = ca_cert.get_subject()

        with open('{}_key.pem'.format(ca_name), 'rb') as f:
            ca_key = crypto.load_privatekey(crypto.FILETYPE_PEM, f.read())
            issuer_key = ca_key

    cert.set_issuer(issuer)
    cert.set_pubkey(key)

    if cert_type == CERT_TYPE_CA:  # prepare extensions for CA
        cert.add_extensions([
            crypto.X509Extension(b'subjectKeyIdentifier', False, b'hash', subject=cert),
        ])
        cert.add_extensions([
            crypto.X509Extension(b'authorityKeyIdentifier', False, b'keyid:always', issuer=cert),
        ])
        cert.add_extensions([
            crypto.X509Extension(b'basicConstraints', False, b'CA:TRUE'),
            crypto.X509Extension(b'keyUsage', False, b'keyCertSign, cRLSign'),
        ])

    else:  # prepare extensions for end-entity certs
        if cert_type == CERT_TYPE_SERVER:
            usage = b'serverAuth'
        else:
            usage = b'clientAuth'

        cert.add_extensions([
            crypto.X509Extension(b'basicConstraints', False, b'CA:FALSE'),
            crypto.X509Extension(b'subjectKeyIdentifier', False, b'hash', subject=cert),
        ])
        cert.add_extensions([
            crypto.X509Extension(b'authorityKeyIdentifier', False, b'keyid:always', issuer=ca_cert),
            crypto.X509Extension(b'extendedKeyUsage', False, usage),
            crypto.X509Extension(b'keyUsage', False, b'digitalSignature'),
        ])

    cert.sign(issuer_key, 'sha256')

    config_data = {
        'host': '',
        'dh': '',
    }

    if cert_type in (CERT_TYPE_CA, CERT_TYPE_SERVER) or not is_embed:
        with open('{}_cert.pem'.format(name), 'wb') as f:
            f.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
        with open('{}_key.pem'.format(name), 'wb') as f:
            f.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

    if cert_type == CERT_TYPE_SERVER:
        config_data.update({
            'ca': 'ca {}_cert.pem'.format(ca_name),
            'cert': 'cert {}_cert.pem'.format(name),
            'key': 'key {}_key.pem'.format(name),
            'dh': 'dh dh.pem',
            'host': '''server 10.8.0.0 255.255.255.0
port 1194''',
        })

        with open('{}.conf'.format(name), 'w') as f:
            f.write(CONFIG_TEMPLATE.format(**config_data))

    elif cert_type == CERT_TYPE_CLIENT:
        if is_embed:
            config_data.update({
                'ca': '<ca>\n{}</ca>'.format(crypto.dump_certificate(crypto.FILETYPE_PEM, ca_cert).decode()),
                'cert': '<cert>\n{}</cert>'.format(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode()),
                'key': '<key>\n{}</key>'.format(crypto.dump_privatekey(crypto.FILETYPE_PEM, key).decode()),
            })
        else:
            config_data.update({
                'ca': 'ca {}_cert.pem'.format(ca_name),
                'cert': 'cert {}_cert.pem'.format(name),
                'key': 'key {}_key.pem'.format(name),
            })

        config_data.update({
            'host': '''client
remote {} 1194
nobind'''.format(host_name),
        })

        with open('{}.{}'.format(name, 'ovpn' if is_embed else 'conf'), 'w') as f:
            f.write(CONFIG_TEMPLATE.format(**config_data))


def gencert(login, is_embed=True):
    dh_name = 'dh'
    if not os.path.exists('{}.pem'.format(dh_name)):
        _generate_diffie_hellman(dh_name, key_size=2048)
        print('Generated Diffie Hellman parameters: "{}"'.format(dh_name))

    ca_name = 'ca'
    if (not os.path.exists('{}_cert.pem'.format(ca_name)) or
            not os.path.exists('{}_key.pem'.format(ca_name))):
        _generate(CERT_TYPE_CA, 'ca')
        print('Generated CA certificate: "{}"'.format(ca_name))

    user, _, host = login.partition('@')
    if (not os.path.exists('{}_cert.pem'.format(host)) or
            not os.path.exists('{}_key.pem'.format(host)) or
            not os.path.exists('{}.conf'.format(host))):
        _generate(CERT_TYPE_SERVER, host, ca_name=ca_name, dh_name=dh_name)
        print('Generated server certificate: "{}"'.format(host))

    if is_embed:
        if not os.path.exists('{}.ovpn'.format(user)):
            _generate(CERT_TYPE_CLIENT, user, ca_name=ca_name, host_name=host, is_embed=is_embed)
            print('Generated client config: "{}"'.format(user))
    else:
        if (not os.path.exists('{}_cert.pem'.format(user)) or
                not os.path.exists('{}_key.pem'.format(user)) or
                not os.path.exists('{}.conf'.format(user))):
            _generate(CERT_TYPE_CLIENT, host, ca_name=ca_name, host_name=host, is_embed=is_embed)
            print('Generated client certificate: "{}"'.format(user))


if __name__ == '__main__':
    gencert(sys.argv[1], is_embed='--no-embed' not in sys.argv)
